
var Q = require("q");
var moment = require("moment");
var constants = require("x-constants");
var config = require("x-config");
var queue = require("x-queue");
var service = require("x-docServiceProxy");
var async = require("async");
var log = require('x-log');

var APP_NAME = 'doc-query';


function run(callback) {

    callback = callback || Function;

    log.init({
        domain: process.env.COMPUTERNAME || '',
        instanceId: log.getInstanceId(),
        app: APP_NAME,
        level: config.log.level,
        transporters: config.log.transporters
    }, function (err) {
        if (err) return callback(new Error('Failed to initialize logging, err:', err));

        console.info('====================================================');
        console.info('Checking for new papers...');
        console.info('====================================================');

        // 1) Check for new items in queue
        // 2) while queue has items:
        //  2.1) pop item
        //  2.2) download paper with paper id
        //  2.3) parse paper into sentances
        //  2.4) insert each sentance into sentances queue

        // Initializing queues
        var queueOutConfig = {
            storageName: config.storage.account,
            storageKey: config.storage.key,
            queueName: config.queues.new_ids,
            checkFrequency: 5000 /* every 5 seconds */
        };
        var queueInConfig = {
            storageName: config.storage.account,
            storageKey: config.storage.key,
            queueName: config.queues.trigger_query,
            checkFrequency: 5000 /* every 5 seconds */
        };
        var queueOut = queue(queueOutConfig);
        var queueIn = queue(queueInConfig);
        queueIn.init(function (err) {
            if (err) {
                console.error(err);
                return callback(err);
            }
            console.info('start processing trigger queue');
            
            return queueOut.init(function (err) {
                if (err) {
                    console.error(err);
                    return callback(err);
                }
                console.info('start processing new ids queue');
                return checkTrigger();
            });
        });
        
        function checkTrigger() {
            return getTriggerMessage(function (err) {
                if (err) console.error(err);
                
                return setNextCheck();
            });
        }

        function getTriggerMessage(cb) {
            return queueIn.getSingleMessage(function (error, message) {
                if (error) {
                    console.error('problem querying trigger queue', error);
                    return cb(error)
                }
                
                if (!message || !message.messagetext) {
                    console.info('no trigger messages were found');
                    return cb();
                }

                var messageDetails;
                
                try {
                    messageDetails = JSON.parse(message.messagetext);
                } catch (error) {
                    console.error('error while parsing trigger message', message, error);
                }
                
                console.info('found trigger message with request type: ', messageDetails.requestType);
                if (messageDetails && messageDetails.requestType == 'trigger') {
                    
                    var fromDate = messageDetails.data && messageDetails.data.fromDate || null;
                    var toDate = messageDetails.data && messageDetails.data.toDate || null;
                    
                    return queryNewDocumentIDs(fromDate, toDate, function (err) {
                        
                        if (error) {
                            console.error('error while processing trigger message', error);
                            return cb(error);
                        }

                        return deleteQueueMessage(message, cb);
                    });
                }
                
                return deleteQueueMessage(message, cb);

                function deleteQueueMessage(message, cb) {
                    
                    if (!message) return cb();

                    return queueIn.deleteMessage(message, function (error) {
                        
                        if (error) {
                            console.error('error while deleting trigger message', error);
                            return cb(error);
                        }

                        return cb();
                    });
                }
            });
        }

        function queryNewDocumentIDs(reqFromDate, reqToDate, cb) {

            // Checking that a message returned from the queue
            // if no message was returned, the queue is empty
            var toDate = (reqToDate && moment(reqToDate)) || moment();
            var fromDate = (reqFromDate && moment(reqFromDate)) || moment().add(-3, 'days'); // TODO: change to 0 days (only today)
            console.info('getting papers from {} to {}', fromDate.format('YYYY-MM-DD'), toDate.format('YYYY-MM-DD'));

            // Run query for document in specific date
            return service.getPapers(fromDate.toDate(), toDate.toDate(), function (error, documents) {
                if (error) {
                    console.error('There were several errors while retrieving the papers.');
                    return cb(error);
                }

                if (!documents || !Array.isArray(documents)) {
                    console.warning('Returned data is not an array');
                    return cb();
                }

                console.info('Found %s new documents', documents.length);
                
                // Queue all new document ids
                async.each(documents, enqueueDocument, function (err) {
                    if (err) {
                        console.error('failed to queue messages for documents.');
                        return cb(err);
                    }
                    
                    // Test Dependency:
                    // The following message is used as part of E2E testing
                    console.info('done queuing messages for all documents');
                    return cb();
                });

                return console.info('Completed iterating through retrieved documents, waiting for results to complete...');

                // Queuing each document as a pending request for processing
                function enqueueDocument(doc, cb) {
                    var message = {
                        "requestType": constants.queues.action.GET_DOCUMENT,
                        "data": {
                            "docId": doc.docId,
                            "sourceId": doc.sourceId
                        }
                    };

                    return queueOut.sendMessage(message, function (err) {
                        if (error) {
                            console.error('There was an error queuing a document.');
                            return cb(err);
                        }

                        // Test Dependency:
                        // The following message is used as part of E2E testing
                        console.info('Queued document %s from source %s', doc.docId, doc.sourceId)
                        return cb();
                    });
                }
            });
        }

        function setNextCheck () {
            console.info('Setting next check in %s milliseconds', queueOutConfig.checkFrequency);
            setTimeout(checkTrigger, queueOutConfig.checkFrequency);
        }
    });
}

module.exports = {
    run: run
};