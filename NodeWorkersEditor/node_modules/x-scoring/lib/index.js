
var async = require('async');
var request = require('request')
var config = require('x-config');
var log = require('x-log');
var path = require('path');
var tedious = require('tedious');
var config = require('x-config');
var queue = require('x-queue');
var db = require('x-db');
var constants = require('x-constants');

var APP_NAME = 'scorer';

var scoringUrls = [config.services.scoring[0]];

function run(cb) {
  cb = cb || Function;

  log.init({
    domain: process.env.COMPUTERNAME || '',
    instanceId: log.getInstanceId(),
    app: APP_NAME,
    level: config.log.level,
    transporters: config.log.transporters
  },
    function (err) {
      if (err) return cb(new Error('Failed to initialize logging, err:', err));
      console.log('starting scoring worker...');

      var queueConfig = {
        storageName: config.storage.account,
        storageKey: config.storage.key,
        queueName: config.queues.scoring,
        checkFrequency: 5000
      };

      var queueIn = queue(queueConfig);
      queueIn.init(function (err) {
        if (err) return cb(err);
        console.log('start processing scoring queue');
        checkQueue();
      });

      
      /* 
      queue item sample:
      
      {"requestType":"score","data":{"sourceId":2,"docId":"2000354","sentenceIndex":129,"sentence":"Similarly, an examination of the deep sequencing data depicted in Table S1 in the report by Ruby and coworkers  also shows that miR-84 has 3 main variations.","mentions":[{"id":"3038","type":"gene","value":"has 3"},{"id":"1128","type":"gene","value":"miR"},{"id":"5719","type":"gene","value":"S1"},{"id":"6267","type":"gene","value":"S1"},{"id":"6205","type":"gene","value":"S1"},{"id":"8241","type":"gene","value":"S1"},{"id":"5707","type":"gene","value":"S1"},{"id":"79187","type":"gene","value":"miR"},{"id":"406904","type":"gene","value":"miR"},{"id":"220972","type":"gene","value":"miR"},{"id":"29116","type":"gene","value":"miR"},{"id":"83856","type":"gene","value":"miR"},{"id":"22877","type":"gene","value":"miR"},{"type":"miRNA","value":{"mirna":"hsa-mir-84","origin":"miR-84"}}]}}
      */

      function checkQueue() {
        console.log('checking queue...');
        queueIn.getSingleMessage(function (err, message) {
          if (err) {
            console.error('error getting message from queue', err);
            return setNextCheck();
          }

          if (!message) {
            return setNextCheck();
          }

          return processMessage(message, function (err) {
            if (err) console.error('error processing message:', message.messageid, err);
            
            // move to the next message
            return checkQueue();
          });
        });
      }

      function setNextCheck() {
        setTimeout(checkQueue, queueConfig.checkFrequency);
      };

      function processMessage(message, cb) {
        console.log('new sentence', message);

        var msgObject;
        try {
          msgObject = JSON.parse(message.messagetext);
        }
        catch (err) {
          console.error('error parsing message, invalid json, deleting...', message);
          return deleteMessage(message);
        }

        var data = msgObject.data && msgObject.data;
        if (!data) {
          console.error('message does not contain data field, deleting...', message);
          return deleteMessage(message);
        }

        if (msgObject.requestType == constants.queues.action.LAST_ITEM_TO_SCORE) {
          
            // update document status to Processed
            return db.updateDocumentStatus({
                sourceId: data.sourceId,
                docId: data.docId,
                statusId: constants.documentStatus.PROCESSED
              },
              function (err) { 
                if (err)  return cb(err);
              
                // delete message from queue
                return queueIn.deleteMessage(message, function (err) {
                  if (err) return cb(err);
                  console.info('item deleted from queue');
                  return cb();
                });
            });
        }


        if (msgObject.requestType !== constants.queues.action.SCORE) {
          console.error('message should not appear in this queue, deleting...', message);
          return deleteMessage(message);
        }

        return getScoring2(data, function (err, result) {
          // if we had an error getting the scoring for the message,
          // we'll return and hopefully the message will be scored the next
          // time we try...
          if (err) {
            console.error('error getting scoring for message', err);
            return cb(err);
          }

          console.log('got scoring relations', JSON.stringify(result));

          if (!result.relations || !result.relations.length) {
            console.error('scorer didn\'t return relations for sentence', data, result);

            // should we delete the message from the queue? 
            // should we leave it there for reprocessing?
            return deleteMessage(message);
          }

          data.entities = result.entities;
          data.relations = result.relations;
          
          // insert relations into db
          return db.upsertRelations(data, function (err) {
            
            // if we had an error inserting into db, we don't want to delete from the queue,
            // just return and hopefully the next iteration will work.
            // the item will stay in the queue until it will be processed.
            if (err) {
              console.error('error updating relation in db', err)
              return cb(err);
            }
            
            // item was processed and saved in db successfully- delete from queue
            return deleteMessage(message, cb);
          });
        });

        function deleteMessage(message) {
          return queueIn.deleteMessage(message, function (err) {
            if (err) return cb(new Error('error deleting item from queue', err));
            console.log('item deleted from queue', message.messageid);
            return cb();
          });
        }
      };





      







      function getScoring2(data, cb) {

        /*
        // TODO: workaround. should we send name or value for the mentions?
        data.mentions.forEach(function (mention) { 
          mention.name = mention.value;
        });
*/
        async.map(scoringUrls,
          function (scoringUrl, cb) {

            var opts = {
              url: scoringUrl,
              method: 'post',
              json: {
                text: data.sentence,
                entities: data.mentions
              }
            };
            
            console.log('requesting scoring', JSON.stringify(opts));
            
            return request(opts, function (err, resp, body) {
              console.log('body', body);
              
              if (err) return cb(err);
              if (resp.statusCode !== 200) return cb(new Error('error: statusCode=' + resp.statusCode));
              
              console.log('scoring', JSON.stringify(body));
              
              var results = {
                relations: [],
                entities: []
              };
              
              var relations = body && body.relations || [];
              relations.forEach(function (relation) {
                
                var entities = relation.entities || []; 
                entities = entities.map(function (entity) {
                    
                  return {
                    typeId: constants.conceptTypes[entity.type.toUpperCase()],
                    id: entity.id,
                    name: entity.value
                  }
                });
                
                // check that we have at least one mirna and one gene
                var genes = entities.filter(function (entity) {
                  return entity.typeId === constants.conceptTypes.GENE ? entity : null;
                });

                var mirnas = entities.filter(function (entity) {
                  return entity.typeId === constants.conceptTypes.MIRNA ? entity : null;
                });
                
                var entitiesHash = {};
                entities.forEach(function (entity) {
                  var key = entity.type + '~' + entity.id;
                  if (!entitiesHash[key]) {
                    entitiesHash[key] = 1;
                    console.log('adding entity');
                    results.entities.push(entity);
                  }
                });
                
                console.log('entities to add:', JSON.stringify(results.entities));
                
                var relationsHash = {};
                mirnas.forEach(function (mirna) {
                  genes.forEach(function (gene) {
                    var key = mirna.id + '~' + gene.id;
                    if (relationsHash[key]) return;
                    relationsHash[key] = 1;
                    results.relations.push({
                      modelVersion: body.modelVersion,
                      entity1: mirna,
                      entity2: gene,
                      relation: relation.class || relation.classification,
                      score: relation.score
                    });
                  })
                });
              });
              
              return cb(null, results);
            });
          },
          function (err, results) {
            if (err) return cb(err);

            var entities = [],
              relations = [];
              
            results.forEach(function (result) {
              entities = entities.concat(result.entities);
              relations = relations.concat(result.relations);
            });

            var result = { entities: entities, relations: relations };
            console.log('finished processing scoring for sentence', relations);
            return cb(null, result);
          }
        );

       
      }

      function getScoring(data, cb) {
        console.log('scoring sentence', data);

        var sentence = data.sentence;
        var relations = [];

        var GENERIC_NAME = 'XXXXXXXX';

        var genericIndex = 1;

        for (var i = 0; i < data.mirnas.length; i++)
          for (var j = 0; j < data.genes.length; j++)
            relations.push({
              entity1: data.mirnas[i],
              entity2: data.genes[j]
            });

        // get scoring for all mirna-gene combinations
        async.map(relations,
          function (relation, cb) {

            var generic1 = GENERIC_NAME + (genericIndex++);
            var generic2 = GENERIC_NAME + (genericIndex++);
            
            var text = replace(relation.entity1.name, generic1, sentence)
              .replace(relation.entity2.name, generic2, sentence);

            console.log('scoring text:', text, 'sentence:', sentence);

            var opts = {
              url: skServiceUrl,
              method: 'post',
              json: {
                text: text,
                entity1: generic1,
                entity2: generic2
              }
            };
            return request(opts, function (err, resp, body) {
              console.log('body', body);
              if (err) return cb(err);
              if (resp.statusCode !== 200) return cb(new Error('error: statusCode=' + resp.statusCode));
              
              try {
                console.log('scoring', body.scoring);

                // sort based on score, get last element- 
                // which is the one with the highest scoring
                var scoring = body.scoring.sort(function (a, b) {
                  return a.score > b.score;
                }).pop();
                
                var result = {
                  modelVersion: body.modelVersion,
                  entity1: relation.entity1,
                  entity2: relation.entity2,
                  relation: scoring.class,
                  score: scoring.score
                }
              }
              catch (err) {
                return cb(err);
              }

              return cb(null, result);
            });
          },
          function (err, relations) {
            if (err) return cb(err);
            console.log('finished processing scoring for sentence', relations);
            return cb(null, { relations: relations });
          }
        );

        function replace(find, replace, text) {
          var re = new RegExp(find, 'g');
          var res = text.replace(re, replace);
          return res;
        }
      }
    });
}

module.exports = {
    run: run
}