var Q = require("q");
var constants = require("x-constants");
var config = require("x-config");
var queue = require("x-queue");
var service = require("x-docServiceProxy");
var async = require("async");
var db = require("x-db")

var log = require('x-log');
var APP_NAME = 'paper-parser';

function run(callback) {
    
    callback = callback || Function;
    
    log.init({
        domain: process.env.COMPUTERNAME || '',
        instanceId: log.getInstanceId(),
        app: APP_NAME,
        level: config.log.level,
        transporters: config.log.transporters
    }, function (err) {
        if (err) return callback(new Error('Failed to initialize logging, err:', err));
        
        
        console.info('====================================================');
        console.info('Checking for new papers...');
        console.info('====================================================');
        
        // 1) Check for new items in queue
        // 2) while queue has items:
        //  2.1) pop item
        //  2.2) download paper with paper id
        //  2.3) parse paper into sentances
        //  2.4) insert each sentance into sentances queue
        
        // Initializing queues
        var queueInConfig = {
            storageName: config.storage.account,
            storageKey: config.storage.key,
            queueName: config.queues.new_ids,
            checkFrequency: 5000
        };
        var queueOutConfig = {
            storageName: config.storage.account,
            storageKey: config.storage.key,
            queueName: config.queues.scoring,
            checkFrequency: 5000
        };
        
        var queueIn = queue(queueInConfig);
        var queueOut = queue(queueOutConfig);
        
        queueOut.init(function (err) {
            if (err) {
                console.error(err);
                return callback(err);
            }
            console.info('start processing scoring queue');
            
            return queueIn.init(function (err) {
                if (err) {
                    console.error(err);
                    return callback(err);
                }
                console.info('start processing new ids queue');
                
                checkQueue();
            });
        });
        
        function checkQueue() {
            console.info("Querying for next message in queue");
            queueIn.getSingleMessage(function (err, message) {
                if (err) {
                    console.error(err);
                    
                    // Retry in a while
                    return setNextCheck();
                }
                console.info('Start processing message from queue...');
                
                processMessage(message, function (err) {
                    if (err) console.error(err);
                    
                    return setNextCheck();
                });
            });
        }
        
        function processMessage(message, cb) {
            
            // Checking that a message returned from the queue
            // if no message was returned, the queue is empty
            if (!message) { return cb(); }
            
            var messageDetails;
            try {
                messageDetails = JSON.parse(message.messagetext);
            } catch (err) {
                console.error('error parsing json', message, err);
                return cb(err);
            }
            var messageData = messageDetails.data;
            var docId = parseInt(messageData.docId);
            var sourceId = messageData.sourceId;
            
            if (sourceId !== constants.sources.PMC) {
                console.info('Skipping message processing, since it is not PMC source');
                return cb();
            }
            
            console.info("Processing document id %s from %s...", docId, sourceId);
            
            // Add a "Processing" status to document
            return db.upsertDocument({
              sourceId: sourceId,
              docId: docId,
              statusId: constants.documentStatus.PROCESSING    
              }, function (err, result) {
                
                if (err) {
                    console.error('There was an error inserting document row into database.');
                    return cb(err);
                }
                
                // PMC: getting sentences of document from PMC service (TODO: extend for pubmed)
                console.log('Searching for sentences...');
                return service.getDocumentSentences(docId, sourceId, function (err, sentencesArray) {
                    if (err) {
                      console.error(err);
                      
                      if (err.errorCode == service.ERRORS.NOT_ACCESSIBLE) {
                        // the document is not accessible, no point in retrying.
                        // we should delete it from the queue
                        
                        // mark status as NOT ACCESSIBLE in the DB
                        var updateStatusOpts = {
                          sourceId: messageData.sourceId,
                          docId: messageData.docId,
                          statusId: constants.documentStatus.NOT_ACCESSIBLE
                        };
                        return db.updateDocumentStatus(updateStatusOpts, function (err) { 
                          if (err) {
                            console.error('error updating document status in db', updateStatusOpts, err);
                            return cb(err);
                          }
                          
                          // delete message from queue
                          console.warn('document is not accessible, deleting item', message);
                          return queueIn.deleteMessage(message, function (err) {
                              if (err) {
                                  console.error('error deleting item from queue %s', err);
                                  return cb(err);
                              }
                              
                              console.info('item deleted from queue');
                              return cb();
                          });
                        });
                      }
                        
                      return cb(err);
                    }
                    
                    // filter out sentences with no mirna and genes,
                    // normalize mention schemas (workaround until Giovanny fixes his code)
                    // remove duplicate mentions
                    // capture sentence index in the array
                    var sentences = sentencesArray.sentences
                      .filter(function (sentence) { 
                        //var cache = {};
                        var entities = sentence.mentions
                          // fix entities data
                          .map(function (mention) {
                            // this is a workaround, waiting for Giovanney to fix
                            if (typeof mention.value !== 'string') mention.value = mention.value.mirna || mention.value.origin || 'aaaaa';
                            mention.type = mention.type.toLowerCase(); 
                            return mention;
                          })
                          /*
                          // filter multiple instance of the same mentions
                          .filter(function (entity) {
                            var key = entity.type + '-' + entity.id;
                            if (!cache[key]) {
                              cache[key] = 1;
                              return entity;
                            }
                            return null;
                          })*/;
                         
                     
                        // check that we have at least one mirna and one gene
                        var genes = entities.filter(function (mention) {
                          return mention.type === constants.entitiesName.GENE ? mention : null;
                        });

                        var mirnas = entities.filter(function (mention) {
                          return mention.type === constants.entitiesName.MIRNA ? mention : null;
                        });
                        
                        // filter out sentences with no mirna and genes,
                        if (!genes.length || !mirnas.length) {
                          console.log('filtering out a sentence with no mirna and gene', sentence);
                          return null;
                        }
                          
                        return sentence; 
                      })
                      // capture sentence index in the array
                      .map(function (sentence, index) {
                        return { data: sentence, index: index };
                    });
                    
                    console.info('Found %s relevant sentences for scoring', sentences.length);
                    
                    // Asynchronously queuing all sentences in current document
                    return async.each(sentences, processSentence, function (err) {
                        if (err) {
                            console.error(err);
                            return cb(err);
                        }
                        
                        // Test Dependency:
                        // The following message is used as part of E2E testing
                        console.info('done queuing messages for document <%s>', docId);

                        // send a last item to the queue to mark that
                        // the processing of this document is done 
                        var msg = {
                          requestType: constants.queues.action.LAST_ITEM_TO_SCORE,
                          data: {
                            sourceId: messageData.sourceId,
                            docId: docId  
                          }
                        };
                        return queueOut.sendMessage(msg, function (err) {
                          if (err) return cb(err);
                            
                          console.log('Queued last item mark');
                        
                          // update document status to SCORING
                          return db.updateDocumentStatus({
                            sourceId: sourceId,
                            docId: docId,
                            statusId: constants.documentStatus.SCORING
                          }, function (err) { 
                            if (err)  return cb(err);
                          
                            // delete message from queue
                            return queueIn.deleteMessage(message, function (err) {
                              if (err) {
                                console.error('error deleting item from queue %s', err);
                                return cb(err);
                              }

                              console.info('item deleted from queue');
                              return cb();
                            });
                          });  
                        });
                    });
                    
                    function processSentence(sentence, cb) {
                      var message = {
                        requestType: constants.queues.action.SCORE,
                        data: {
                          sourceId: messageData.sourceId,
                          docId: docId,
                          sentenceIndex: sentence.index,
                          sentence: sentence.data.sentence,
                          mentions: sentence.data.mentions
                        }
                      };
                        
                      return queueOut.sendMessage(message, function (err) {
                          if (err) {
                              console.error('failed to queue message: <%s> of paper <%s>', message, docId);
                              return cb(err);
                          }
                          
                          console.info('Queued sentence %s in document %s from source %s', sentence.index, docId, messageData.sourceId)
                          return cb();
                      });
                    }
                });
            });
        }
        
        function setNextCheck() {
            console.info('Setting next check in %s milliseconds', queueInConfig.checkFrequency);
            return setTimeout(checkQueue, queueInConfig.checkFrequency);
        }
    });
}

module.exports = {
    run: run
};